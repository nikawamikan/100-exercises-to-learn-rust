// TODO: based on what you learned in this section, replace `todo!()` with
//  the correct **stack size** for the respective type.
#[cfg(test)]
mod tests {
    use std::mem::size_of;

    #[test]
    fn u16_size() {
        // u16型のサイズは2バイト
        assert_eq!(size_of::<u16>(), 2);
    }

    #[test]
    fn i32_size() {
        // i32型のサイズは4バイト
        assert_eq!(size_of::<i32>(), 4);
    }

    #[test]
    fn bool_size() {
        // bool型のサイズは1バイト
        // 理論的には1bitで十分だが、1バイトが最小の単位となる。
        // これはメモリアクセスが1バイト単位で行われるためである。
        assert_eq!(size_of::<bool>(), 1);
    }

    // 上記を書いていて思いついたが、これはメモリのアクセス単位が1バイトとして処理するのが理由であろう。
    // これによりコンピューターのbit数が少ない時代は多くのメモリを利用することが可能だったと考えられる。
    // 例えば、8bitコンピューターを考えた場合、1bitごとにアドレスで管理した場合、32バイトしか利用できない。
    // これを、1バイトごとにアドレスで管理した場合、256バイト利用できる。
    // もっとも、8bit時代のコンピューターでは恐らく、boolのような真偽値を扱う場合は、
    // 0b10101011(実体) and 0b00000001(マスク) のようにbit演算を行っていたのではないかと思われる。
    // こうすれば真偽値は1bitで表現できるため、メモリの節約になる。(計算量は増えるが)
    // ちなみに上記は推測。実際にどうだったかは知らないので気が向いたら調べてみるとしよう。
    // 32bitOSなどでは2^32のアドレス空間を持つため、利用できるメモリの最大量が4GiBとなる。
    // これは、32bitの整数型で表現できる最大値が4,294,967,295であるためである。
    // 64bitOSでは2^64のアドレス空間を持つため、メモリの最大量が18.4エクサバイトとなる。
    // これは、64bitの整数型で表現できる最大値が18,446,744,073,709,551,615であるためである。
    // なお、実際に利用できるメモリ量はOSによって異なる。
}
